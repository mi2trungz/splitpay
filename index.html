<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <title>Quiz luy·ªán c√¢u sai (d√°n ƒë·ªÅ + ƒë√°p √°n)</title>
  <style>
    :root {
      color-scheme: dark;
    }

    body {
      font-family: Arial, sans-serif;
      background: #020617; /* slate-950 */
      padding: 20px;
      color: #e5e7eb; /* gray-200 */
    }

    .box {
      background: #020617;
      padding: 20px;
      margin-bottom: 20px;
      border-radius: 14px;
      box-shadow: 0 10px 30px rgba(15,23,42,0.8);
      border: 1px solid #1f2937; /* gray-800 */
      max-width: 1100px;
      margin-left: auto;
      margin-right: auto;
    }

    h2 {
      margin-top: 0;
      color: #e5e7eb;
    }

    p {
      color: #9ca3af; /* gray-400 */
    }

    textarea,
    input,
    select {
      width: 100%;
      padding: 8px;
      margin-top: 6px;
      margin-bottom: 12px;
      border-radius: 8px;
      border: 1px solid #374151; /* gray-700 */
      font-family: inherit;
      background: #020617;
      color: #e5e7eb;
      outline: none;
      box-shadow: inset 0 0 0 1px rgba(15,23,42,0.6);
    }

    textarea:focus,
    input:focus,
    select:focus {
      border-color: #6366f1; /* indigo-500 */
      box-shadow: 0 0 0 1px #6366f1;
    }

    textarea {
      min-height: 180px;
      resize: vertical;
    }

    pre {
      background: #020617;
      padding: 8px;
      border-radius: 8px;
      border: 1px solid #1f2937;
      color: #9ca3af;
      white-space: pre-wrap;
    }

    button {
      padding: 10px 18px;
      border: none;
      border-radius: 999px;
      background: #6366f1; /* indigo-500 */
      color: white;
      cursor: pointer;
      font-weight: bold;
      margin-right: 8px;
      box-shadow: 0 8px 20px rgba(99,102,241,0.4);
      transition: transform 0.08s, box-shadow 0.08s, opacity 0.15s;
    }

    button:hover {
      opacity: 0.95;
      box-shadow: 0 10px 26px rgba(99,102,241,0.5);
    }

    button:active {
      transform: translateY(1px);
      box-shadow: 0 6px 18px rgba(99,102,241,0.4);
    }

    .secondary-btn {
      background: #111827;
      color: #e5e7eb;
      box-shadow: 0 4px 12px rgba(15,23,42,0.7);
    }

    .danger-btn {
      background: #b91c1c;
      box-shadow: 0 4px 12px rgba(185,28,28,0.6);
    }

    .inline-row {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
    }

    .inline-row > * {
      flex: 1;
      min-width: 120px;
    }

    .inline-row button {
      flex: 0 0 auto;
      margin-top: 0;
      margin-bottom: 0;
    }

    .question-card {
      padding: 20px;
      background: #020617;
      border-radius: 14px;
      box-shadow: 0 10px 30px rgba(15,23,42,0.9);
      margin-top: 10px;
      border: 1px solid #1f2937;
      max-width: 1100px;
      margin-left: auto;
      margin-right: auto;
    }

    #progress {
      margin-bottom: 8px;
      font-size: 14px;
      color: #9ca3af;
    }

    #quiz-title {
      font-size: 18px;
      margin-bottom: 6px;
    }

    #quiz-text {
      color: #d1d5db;
      margin-bottom: 12px;
    }

    /* ====== BLOCK ANSWER STYLE ====== */
    .choice-row {
      margin-bottom: 10px;
    }

    .choice-card {
      width: 100%;
      display: flex;
      align-items: flex-start;
      gap: 10px;
      padding: 10px 14px;
      border-radius: 12px;
      border: 1px solid #1f2937;
      background: #020617;
      cursor: pointer;
      transition: border-color 0.12s, background 0.12s,
                  box-shadow 0.12s, transform 0.05s;
      text-align: left;
    }

    .choice-card:hover {
      border-color: #4f46e5;
      background: #020617;
      box-shadow: 0 0 0 1px rgba(79,70,229,0.5);
    }

    .choice-card.selected {
      border-color: #6366f1;
      background: #111827;
      box-shadow: 0 0 0 1px rgba(99,102,241,0.8);
      transform: translateY(-1px);
    }

    .choice-prefix {
      font-weight: 600;
      color: #9ca3af;
      flex-shrink: 0;
      min-width: 20px;
    }

    .choice-text {
      color: #e5e7eb;
      white-space: normal;
    }

    #status {
      margin-top: 12px;
      font-weight: bold;
    }

    #status.ok {
      color: #4ade80; /* green-400 */
    }

    #status.err {
      color: #fb7185; /* rose-400 */
    }

    .small-hint {
      font-size: 12px;
      color: #9ca3af;
      margin-top: -6px;
      margin-bottom: 10px;
    }
  </style>
</head>
<body>

<!-- ====== NH·∫¨P ƒê·ªÄ + L∆ØU B·ªò ƒê·ªÄ ====== -->
<div class="box">
  <h2>B∆∞·ªõc 1: D√°n ƒë·ªÅ</h2>
  <p><strong>Format v√≠ d·ª•:</strong></p>
  <pre>
C√¢u 14: Assume that U.S. and British investors require a real return of 2%. If the nominal U.S. interest rate is 15%, and the nominal British rate is 13%, then according to the IFE, the British inflation rate is expected to be about the U.S. inflation rate, and the British pound is expected to .
A.2 percentage points above; depreciate by about 2%
B.3 percentage points above; depreciate by about 3%
C.3 percentage points below; appreciate by about 3%
D.2 percentage points below; appreciate by about 2%

C√¢u 15: Assume U.S. and Swiss investors require a real rate of return of 3%. Assume the nominal U.S. interest rate is 6% and the nominal Swiss rate is 4%. According to the international Fisher effect, the franc will by about .
A.appreciate; 3%  B.appreciate; 1%  C.depreciate; 3%  D.appreciate; 2%
  </pre>

  <textarea id="rawQuestions" placeholder="D√°n t·∫•t c·∫£ c√¢u h·ªèi v√†o ƒë√¢y..."></textarea>

  <h2>B∆∞·ªõc 2: Nh·∫≠p ƒë√°p √°n ƒë√∫ng</h2>
  <p>
    V√≠ d·ª•: n·∫øu c√≥ 3 c√¢u v√† ƒë√°p √°n l·∫ßn l∆∞·ª£t l√† A, B, D ‚Üí nh·∫≠p <strong>ABD</strong>.<br>
    K√Ω t·ª± th·ª© 1 ·ª©ng v·ªõi c√¢u h·ªèi <strong>ƒë·∫ßu ti√™n</strong> trong √¥ tr√™n (b·∫•t k·ªÉ s·ªë 14, 15...).
  </p>
  <input id="answerKey" placeholder="V√≠ d·ª•: ABDCDAB..." />

  <h2>B∆∞·ªõc 3: ƒê·∫∑t t√™n & l∆∞u b·ªô ƒë·ªÅ</h2>
  <div class="small-hint">
    V√≠ d·ª•: <em>‚ÄúCh∆∞∆°ng 3 - IFE‚Äù</em>, <em>‚Äúƒê·ªÅ c≈© 2024 - IRP/PPP‚Äù</em>...
  </div>
  <div class="inline-row" style="margin-bottom: 12px;">
    <input id="setName" placeholder="T√™n b·ªô ƒë·ªÅ..." />
    <button onclick="saveCurrentSet()">L∆∞u b·ªô ƒë·ªÅ</button>
  </div>

  <h2>B·ªô ƒë·ªÅ ƒë√£ l∆∞u</h2>
  <div class="inline-row">
    <select id="savedSetsSelect"></select>
    <button onclick="loadSelectedSet()">T·∫£i b·ªô ƒë·ªÅ</button>
    <button class="danger-btn" onclick="deleteSelectedSet()">Xo√° b·ªô ƒë·ªÅ</button>
  </div>
  <div class="inline-row" style="margin-top:8px;">
    <button class="secondary-btn" onclick="exportSets()">Xu·∫•t t·∫•t c·∫£ b·ªô ƒë·ªÅ (.json)</button>
    <button onclick="triggerImportSets()">T·∫£i b·ªô ƒë·ªÅ t·ª´ file</button>
  </div>
  <input type="file" id="setsFileInput" accept="application/json" style="display:none" onchange="importSetsFromFile(event)" />
  <div class="small-hint">
    B·ªô ƒë·ªÅ ƒë∆∞·ª£c l∆∞u trong LocalStorage. B·∫°n c√≥ th·ªÉ xu·∫•t ra file JSON ƒë·ªÉ backup, r·ªìi t·∫£i l√™n l·∫°i khi ƒë·ªïi m√°y ho·∫∑c tr√¨nh duy·ªát.
  </div>

  <h2>L·ªãch s·ª≠ l√†m b√†i</h2>
  <div class="inline-row">
    <button class="secondary-btn" onclick="exportHistory()">Xu·∫•t l·ªãch s·ª≠ (.json)</button>
    <button onclick="triggerImportHistory()">T·∫£i l·ªãch s·ª≠ t·ª´ file</button>
    <button class="danger-btn" onclick="clearHistory()">Xo√° l·ªãch s·ª≠</button>
  </div>
  <input type="file" id="historyFileInput" accept="application/json" style="display:none" onchange="importHistoryFromFile(event)" />
  <div class="small-hint">
    L·ªãch s·ª≠ ghi l·∫°i m·ªói l·∫ßn b·∫°n b·∫•m "Tr·∫£ l·ªùi" (c√¢u, l∆∞·ª£t, ƒë√°p √°n ch·ªçn, ƒë√∫ng/sai...).
  </div>

  <hr style="border-color:#1f2937;margin:18px 0;" />

  <button onclick="createQuiz()">T·∫°o ƒë·ªÅ &amp; b·∫Øt ƒë·∫ßu l√†m b√†i</button>
</div>

<!-- ====== V√ôNG L√ÄM QUIZ ====== -->
<div class="question-card" id="quiz-box" style="display:none;">
  <div id="progress"></div>
  <h2 id="quiz-title">C√¢u h·ªèi</h2>
  <div id="quiz-text"></div>

  <div class="choice-row">
    <div class="choice-card" data-index="0">
      <span class="choice-prefix">A.</span>
      <span class="choice-text" id="c1"></span>
    </div>
  </div>

  <div class="choice-row">
    <div class="choice-card" data-index="1">
      <span class="choice-prefix">B.</span>
      <span class="choice-text" id="c2"></span>
    </div>
  </div>

  <div class="choice-row">
    <div class="choice-card" data-index="2">
      <span class="choice-prefix">C.</span>
      <span class="choice-text" id="c3"></span>
    </div>
  </div>

  <div class="choice-row">
    <div class="choice-card" data-index="3">
      <span class="choice-prefix">D.</span>
      <span class="choice-text" id="c4"></span>
    </div>
  </div>

  <button onclick="submitAnswer()">Tr·∫£ l·ªùi</button>
  <button class="secondary-btn" onclick="restartQuiz()">L√†m l·∫°i t·ª´ ƒë·∫ßu</button>

  <div id="status"></div>
</div>

<script>
let questions = [];   // { text, choices[4], correctIndex }
let roundList = [];   // index c√¢u trong l∆∞·ª£t hi·ªán t·∫°i (theo m·∫£ng questions)
let wrongList = [];   // index c√¢u sai d√πng cho l∆∞·ª£t sau
let current = 0;
let round = 1;
let finished = false;
let selectedChoice = null;
let shuffleEnabled = false; // c√≥ b·∫≠t x√°o tr·ªôn kh√¥ng
let quizHistory = [];       // l·ªãch s·ª≠ l√†m b√†i

const LS_KEY_SETS = "quizSets_v1";          // l∆∞u nhi·ªÅu b·ªô ƒë·ªÅ
const LS_KEY_STATE = "quizCurrentState_v1"; // l∆∞u tr·∫°ng th√°i ƒëang l√†m
const LS_KEY_HISTORY = "quizHistory_v1";    // l∆∞u l·ªãch s·ª≠ l√†m b√†i

// ======== H√ÄM SHUFFLE M·∫¢NG (FISHER-YATES) ========
function shuffleArray(arr) {
  const a = [...arr];
  for (let i = a.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}

// ======== L∆ØU / LOAD B·ªò ƒê·ªÄ T·ª™ LOCALSTORAGE ========
function getSavedSets() {
  try {
    const raw = localStorage.getItem(LS_KEY_SETS);
    if (!raw) return [];
    const parsed = JSON.parse(raw);
    if (!Array.isArray(parsed)) return [];
    return parsed;
  } catch (e) {
    console.error("L·ªói ƒë·ªçc LocalStorage:", e);
    return [];
  }
}

function saveSetsToLS(sets) {
  try {
    localStorage.setItem(LS_KEY_SETS, JSON.stringify(sets));
  } catch (e) {
    console.error("L·ªói l∆∞u LocalStorage:", e);
  }
}

function refreshSavedSetsUI() {
  const select = document.getElementById("savedSetsSelect");
  const sets = getSavedSets();
  select.innerHTML = "";
  if (sets.length === 0) {
    const opt = document.createElement("option");
    opt.value = "";
    opt.textContent = "Ch∆∞a c√≥ b·ªô ƒë·ªÅ n√†o ƒë∆∞·ª£c l∆∞u";
    select.appendChild(opt);
    select.disabled = true;
    return;
  }
  select.disabled = false;
  sets.forEach((set, idx) => {
    const opt = document.createElement("option");
    opt.value = idx;
    opt.textContent = set.name;
    select.appendChild(opt);
  });
}

function saveCurrentSet() {
  const name = document.getElementById("setName").value.trim();
  const raw = document.getElementById("rawQuestions").value.trim();
  const keyInput = document.getElementById("answerKey").value
    .trim()
    .toUpperCase()
    .replace(/\s+/g, "");

  if (!name) {
    alert("B·∫°n ch∆∞a nh·∫≠p t√™n b·ªô ƒë·ªÅ.");
    return;
  }
  if (!raw) {
    alert("B·∫°n ch∆∞a d√°n ƒë·ªÅ v√†o.");
    return;
  }
  if (!keyInput) {
    alert("B·∫°n ch∆∞a nh·∫≠p chu·ªói ƒë√°p √°n.");
    return;
  }

  const sets = getSavedSets();
  const existingIndex = sets.findIndex(s => s.name === name);

  const data = {
    name,
    rawQuestions: raw,
    answerKey: keyInput
  };

  if (existingIndex >= 0) {
    if (confirm("ƒê√£ c√≥ b·ªô ƒë·ªÅ tr√πng t√™n. B·∫°n c√≥ mu·ªën ghi ƒë√® kh√¥ng?")) {
      sets[existingIndex] = data;
    } else {
      return;
    }
  } else {
    sets.push(data);
  }

  saveSetsToLS(sets);
  refreshSavedSetsUI();
  alert("ƒê√£ l∆∞u b·ªô ƒë·ªÅ \"" + name + "\".");
}

function loadSelectedSet() {
  const select = document.getElementById("savedSetsSelect");
  const idx = parseInt(select.value, 10);
  const sets = getSavedSets();
  if (isNaN(idx) || !sets[idx]) {
    alert("Kh√¥ng c√≥ b·ªô ƒë·ªÅ h·ª£p l·ªá ƒë·ªÉ t·∫£i.");
    return;
  }
  const set = sets[idx];
  document.getElementById("setName").value = set.name;
  document.getElementById("rawQuestions").value = set.rawQuestions;
  document.getElementById("answerKey").value = set.answerKey;
  alert("ƒê√£ t·∫£i b·ªô ƒë·ªÅ: " + set.name);
}

function deleteSelectedSet() {
  const select = document.getElementById("savedSetsSelect");
  const idx = parseInt(select.value, 10);
  const sets = getSavedSets();
  if (isNaN(idx) || !sets[idx]) {
    alert("Kh√¥ng c√≥ b·ªô ƒë·ªÅ h·ª£p l·ªá ƒë·ªÉ xo√°.");
    return;
  }
  if (!confirm('B·∫°n c√≥ ch·∫Øc mu·ªën xo√° b·ªô ƒë·ªÅ "' + sets[idx].name + '"?')) {
    return;
  }
  sets.splice(idx, 1);
  saveSetsToLS(sets);
  refreshSavedSetsUI();
  alert("ƒê√£ xo√° b·ªô ƒë·ªÅ.");
}

// ======== EXPORT / IMPORT B·ªò ƒê·ªÄ (.JSON) ========
function exportSets() {
  const sets = getSavedSets();
  if (!sets.length) {
    alert("Ch∆∞a c√≥ b·ªô ƒë·ªÅ n√†o ƒë·ªÉ xu·∫•t.");
    return;
  }
  const dataStr = JSON.stringify(sets, null, 2);
  const blob = new Blob([dataStr], { type: "application/json" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  const dateStr = new Date().toISOString().split("T")[0];
  a.href = url;
  a.download = `quiz_sets_${dateStr}.json`;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

function triggerImportSets() {
  const input = document.getElementById("setsFileInput");
  input.click();
}

function importSetsFromFile(event) {
  const file = event.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = e => {
    try {
      const data = JSON.parse(e.target.result);
      if (!Array.isArray(data)) {
        alert("File b·ªô ƒë·ªÅ kh√¥ng ƒë√∫ng ƒë·ªãnh d·∫°ng (ph·∫£i l√† m·∫£ng JSON).");
        return;
      }
      let currentSets = getSavedSets();
      data.forEach(newSet => {
        if (!newSet || typeof newSet !== "object") return;
        if (!newSet.name || !newSet.rawQuestions || !newSet.answerKey) return;
        const idx = currentSets.findIndex(s => s.name === newSet.name);
        if (idx >= 0) {
          // t√™n tr√πng -> ghi ƒë√®
          currentSets[idx] = newSet;
        } else {
          currentSets.push(newSet);
        }
      });
      saveSetsToLS(currentSets);
      refreshSavedSetsUI();
      alert("ƒê√£ import b·ªô ƒë·ªÅ t·ª´ file. T·ªïng s·ªë b·ªô ƒë·ªÅ hi·ªán c√≥: " + currentSets.length);
    } catch (err) {
      console.error(err);
      alert("Kh√¥ng ƒë·ªçc ƒë∆∞·ª£c file JSON b·ªô ƒë·ªÅ.");
    } finally {
      event.target.value = "";
    }
  };
  reader.readAsText(file);
}

// ======== L·ªäCH S·ª¨ L√ÄM B√ÄI (HISTORY) ========
function loadHistoryFromLS() {
  try {
    const raw = localStorage.getItem(LS_KEY_HISTORY);
    if (!raw) return [];
    const parsed = JSON.parse(raw);
    if (!Array.isArray(parsed)) return [];
    return parsed;
  } catch (e) {
    console.error("L·ªói ƒë·ªçc l·ªãch s·ª≠:", e);
    return [];
  }
}

function saveHistoryToLS() {
  try {
    localStorage.setItem(LS_KEY_HISTORY, JSON.stringify(quizHistory));
  } catch (e) {
    console.error("L·ªói l∆∞u l·ªãch s·ª≠:", e);
  }
}

function logHistoryAttempt(qIndex, selectedIdx, correctIdx) {
  if (!questions[qIndex]) return;
  const choiceLetters = ["A", "B", "C", "D"];
  const entry = {
    timestamp: new Date().toISOString(),
    setName: document.getElementById("setName").value.trim() || null,
    questionIndex: qIndex,
    questionText: questions[qIndex].text,
    round,
    positionInRound: current + 1,
    totalInRound: roundList.length,
    selectedChoiceIndex: selectedIdx,
    selectedChoiceLetter: choiceLetters[selectedIdx] || null,
    selectedChoiceText: questions[qIndex].choices[selectedIdx] || null,
    correctChoiceIndex: correctIdx,
    correctChoiceLetter: choiceLetters[correctIdx] || null,
    correctChoiceText: questions[qIndex].choices[correctIdx] || null,
    isCorrect: selectedIdx === correctIdx
  };
  quizHistory.push(entry);
  saveHistoryToLS();
}

function exportHistory() {
  if (!quizHistory || quizHistory.length === 0) {
    alert("Ch∆∞a c√≥ l·ªãch s·ª≠ n√†o ƒë·ªÉ xu·∫•t.");
    return;
  }
  const dataStr = JSON.stringify(quizHistory, null, 2);
  const blob = new Blob([dataStr], { type: "application/json" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  const dateStr = new Date().toISOString().split("T")[0];
  a.download = `quiz_history_${dateStr}.json`;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

function triggerImportHistory() {
  const input = document.getElementById("historyFileInput");
  input.click();
}

function importHistoryFromFile(event) {
  const file = event.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = (e) => {
    try {
      const data = JSON.parse(e.target.result);
      if (!Array.isArray(data)) {
        alert("File kh√¥ng ƒë√∫ng ƒë·ªãnh d·∫°ng l·ªãch s·ª≠ (ph·∫£i l√† m·∫£ng JSON).");
        return;
      }
      quizHistory = data;
      saveHistoryToLS();
      alert("ƒê√£ nh·∫≠p " + data.length + " b·∫£n ghi l·ªãch s·ª≠ t·ª´ file.");
    } catch (err) {
      console.error(err);
      alert("Kh√¥ng ƒë·ªçc ƒë∆∞·ª£c file JSON l·ªãch s·ª≠.");
    } finally {
      event.target.value = ""; // reset input
    }
  };
  reader.readAsText(file);
}

function clearHistory() {
  if (!confirm("B·∫°n c√≥ ch·∫Øc mu·ªën xo√° to√†n b·ªô l·ªãch s·ª≠ l√†m b√†i kh√¥ng?")) return;
  quizHistory = [];
  try {
    localStorage.removeItem(LS_KEY_HISTORY);
  } catch (e) {
    console.error("L·ªói xo√° l·ªãch s·ª≠:", e);
  }
  alert("ƒê√£ xo√° l·ªãch s·ª≠ l√†m b√†i.");
}

// ======== L∆ØU / LOAD TR·∫†NG TH√ÅI QUIZ ========
function saveCurrentState() {
  if (!questions || questions.length === 0) {
    localStorage.removeItem(LS_KEY_STATE);
    return;
  }
  const state = {
    rawQuestions: document.getElementById("rawQuestions").value.trim(),
    answerKey: document.getElementById("answerKey").value.trim().toUpperCase().replace(/\s+/g,""),
    setName: document.getElementById("setName").value.trim(),
    questions,
    shuffleEnabled,
    round,
    current,
    roundList,
    wrongList,
    finished
  };
  try {
    localStorage.setItem(LS_KEY_STATE, JSON.stringify(state));
  } catch (e) {
    console.error("L·ªói l∆∞u tr·∫°ng th√°i quiz:", e);
  }
}

function tryRestoreQuizState() {
  try {
    const raw = localStorage.getItem(LS_KEY_STATE);
    if (!raw) return;
    const state = JSON.parse(raw);
    if (!state || !Array.isArray(state.questions) || state.questions.length === 0) return;

    const setLabel = state.setName ? ('"'+state.setName+'"') : "(ch∆∞a ƒë·∫∑t t√™n)";
    const ok = confirm(
      `Ph√°t hi·ªán b·∫°n c√≥ b√†i ƒëang l√†m d·ªü cho b·ªô ƒë·ªÅ ${setLabel}.\nB·∫°n c√≥ mu·ªën ti·∫øp t·ª•c kh√¥ng?`
    );
    if (!ok) return;

    // Kh√¥i ph·ª•c input
    if (state.rawQuestions) {
      document.getElementById("rawQuestions").value = state.rawQuestions;
    }
    if (state.answerKey) {
      document.getElementById("answerKey").value = state.answerKey;
    }
    if (state.setName) {
      document.getElementById("setName").value = state.setName;
    }

    questions = state.questions;
    shuffleEnabled = !!state.shuffleEnabled;
    round = state.round || 1;
    current = state.current || 0;
    roundList = Array.isArray(state.roundList) && state.roundList.length
      ? state.roundList
      : questions.map((_,i)=>i);
    wrongList = Array.isArray(state.wrongList) ? state.wrongList : [];
    finished = !!state.finished;

    document.getElementById("quiz-box").style.display = "block";
    renderQuestion(); // render s·∫Ω g·ªçi saveCurrentState() l·∫°i
  } catch (e) {
    console.error("L·ªói kh√¥i ph·ª•c tr·∫°ng th√°i quiz:", e);
  }
}

// ==================== PARSE ƒê·ªÄ T·ª™ TEXT ====================
function parseQuestions(raw) {
  // T√°ch th√†nh t·ª´ng block b·∫Øt ƒë·∫ßu b·∫±ng "C√¢u xx:"
  const blocks = raw
    .split(/(?=C√¢u\s*\d+\s*:)/g)
    .map(b => b.trim())
    .filter(b => b.length > 0);

  const parsed = [];

  blocks.forEach((block, idx) => {
    // T√¨m d√≤ng c√¢u h·ªèi (C√¢u xx: ...)
    const qMatch = block.match(/^C√¢u\s*\d+\s*:.*$/m);
    if (!qMatch) {
      console.warn("Kh√¥ng t√¨m ƒë∆∞·ª£c d√≤ng c√¢u h·ªèi trong block", idx + 1, block);
      return;
    }

    const questionText = qMatch[0].trim();
    const afterQuestion = block.slice(qMatch.index + qMatch[0].length).trim();

    // Gom A./B./C./D. k·ªÉ c·∫£ khi n·∫±m chung 1 d√≤ng
    const choicesObj = { A: "", B: "", C: "", D: "" };
    const choiceRegex = /([ABCD])\.(.*?)(?=(?:[ABCD]\.|$))/gs;
    let m;
    while ((m = choiceRegex.exec(afterQuestion)) !== null) {
      const letter = m[1]; // A/B/C/D
      const text = m[2].replace(/\s+/g, " ").trim();
      choicesObj[letter] = text;
    }

    const choiceArray = ["A", "B", "C", "D"].map(ch => (choicesObj[ch] || "").trim());

    if (!questionText || choiceArray.some(c => c.length === 0)) {
      console.warn("Block", idx + 1, "kh√¥ng h·ª£p l·ªá (thi·∫øu A/B/C/D), s·∫Ω b·ªè qua:", block);
      return;
    }

    parsed.push({
      text: questionText,
      choices: choiceArray
    });
  });

  return parsed;
}

// ==================== T·∫†O ƒê·ªÄ T·ª™ TEXT + ƒê√ÅP √ÅN ====================
function createQuiz() {
  const raw = document.getElementById("rawQuestions").value.trim();
  const keyInput = document.getElementById("answerKey").value
    .trim()
    .toUpperCase()
    .replace(/\s+/g, "");

  if (!raw) {
    alert("B·∫°n ch∆∞a d√°n ƒë·ªÅ.");
    return;
  }
  if (!keyInput) {
    alert("B·∫°n ch∆∞a nh·∫≠p chu·ªói ƒë√°p √°n.");
    return;
  }

  let parsedQuestions = parseQuestions(raw);

  if (parsedQuestions.length === 0) {
    alert("Kh√¥ng parse ƒë∆∞·ª£c c√¢u h·ªèi n√†o. Ki·ªÉm tra l·∫°i format 'C√¢u xx:' v√† A./B./C./D.");
    return;
  }

  if (keyInput.length !== parsedQuestions.length) {
    alert(
      "S·ªë k√Ω t·ª± trong chu·ªói ƒë√°p √°n (" +
        keyInput.length +
        ") kh√¥ng kh·ªõp v·ªõi s·ªë c√¢u h·ªèi parse ƒë∆∞·ª£c (" +
        parsedQuestions.length +
        ")."
    );
    return;
  }

  // H·ªéI NG∆Ø·ªúI D√ôNG C√ì MU·ªêN X√ÅO TR·ªòN KH√îNG
  const userWantsShuffle = confirm(
    "B·∫°n c√≥ mu·ªën x√°o tr·ªôn th·ª© t·ª± c√¢u h·ªèi kh√¥ng?\nOK = C√≥, Cancel = Kh√¥ng."
  );
  shuffleEnabled = userWantsShuffle;

  const letterToIndex = { A: 0, B: 1, C: 2, D: 3 };
  const tempQuestions = [];

  for (let i = 0; i < parsedQuestions.length; i++) {
    const ansLetter = keyInput[i];
    const idx = letterToIndex[ansLetter];
    if (idx === undefined) {
      alert(
        "K√Ω t·ª± ƒë√°p √°n kh√¥ng h·ª£p l·ªá t·∫°i v·ªã tr√≠ " +
          (i + 1) +
          ": " +
          ansLetter +
          " (ch·ªâ ch·∫•p nh·∫≠n A/B/C/D)"
      );
      return;
    }
    tempQuestions.push({
      text: parsedQuestions[i].text,
      choices: parsedQuestions[i].choices,
      correctIndex: idx
    });
  }

  questions = tempQuestions;
  // B·∫Øt ƒë·∫ßu quiz m·ªõi ‚Üí ghi ƒë√® state c≈©
  startQuiz();
}

// ==================== B·∫ÆT ƒê·∫¶U L√ÄM B√ÄI ====================
function startQuiz() {
  if (questions.length === 0) {
    alert("Ch∆∞a c√≥ c√¢u h·ªèi.");
    return;
  }
  let indices = questions.map((_, i) => i);
  if (shuffleEnabled) {
    indices = shuffleArray(indices);
  }

  roundList = indices;
  wrongList = [];
  round = 1;
  current = 0;
  finished = false;

  document.getElementById("quiz-box").style.display = "block";
  renderQuestion();
}

// ==================== HI·ªÇN TH·ªä C√ÇU H·ªéI ====================
function renderQuestion() {
  const qIndex = roundList[current];
  const q = questions[qIndex];

  const progressText =
    `L∆∞·ª£t ${round} ‚Äì C√¢u ${current + 1}/${roundList.length} (T·ªïng: ${questions.length} c√¢u)`;
  document.getElementById("progress").innerText = progressText;

  document.getElementById("quiz-title").innerText = q.text;
  document.getElementById("quiz-text").innerText = "";

  document.getElementById("c1").innerText = q.choices[0];
  document.getElementById("c2").innerText = q.choices[1];
  document.getElementById("c3").innerText = q.choices[2];
  document.getElementById("c4").innerText = q.choices[3];

  const statusEl = document.getElementById("status");
  statusEl.innerText = "";
  statusEl.className = "";

  selectedChoice = null;
  updateChoiceSelection();

  // M·ªói l·∫ßn render m·ªôt c√¢u ‚Üí l∆∞u tr·∫°ng th√°i hi·ªán t·∫°i
  saveCurrentState();
}

// ==================== CH·ªåN ƒê√ÅP √ÅN (B·∫§M BLOCK) ====================
function updateChoiceSelection() {
  const cards = document.querySelectorAll(".choice-card");
  cards.forEach(card => {
    const idx = Number(card.getAttribute("data-index"));
    if (idx === selectedChoice) {
      card.classList.add("selected");
    } else {
      card.classList.remove("selected");
    }
  });
}

function attachChoiceEvents() {
  const cards = document.querySelectorAll(".choice-card");
  cards.forEach(card => {
    card.addEventListener("click", () => {
      const idx = Number(card.getAttribute("data-index"));
      selectedChoice = idx;
      updateChoiceSelection();
    });
  });
}

// ==================== N·ªòP ƒê√ÅP √ÅN ====================
function submitAnswer() {
  if (finished) return;

  if (selectedChoice === null) {
    alert("H√£y ch·ªçn m·ªôt ƒë√°p √°n (b·∫•m v√†o block ƒë√°p √°n).");
    return;
  }

  const answer = selectedChoice;
  const qIndex = roundList[current];
  const q = questions[qIndex];
  const statusEl = document.getElementById("status");

  if (answer === q.correctIndex) {
    statusEl.innerText = "ƒê√∫ng r·ªìi! ‚úÖ";
    statusEl.className = "ok";
  } else {
    statusEl.innerText = "Sai ‚Äì c√¢u n√†y s·∫Ω ƒë∆∞·ª£c l√†m l·∫°i ·ªü l∆∞·ª£t sau.";
    statusEl.className = "err";
    if (!wrongList.includes(qIndex)) {
      wrongList.push(qIndex);
    }
  }

  // Ghi v√†o l·ªãch s·ª≠
  logHistoryAttempt(qIndex, answer, q.correctIndex);

  // L∆∞u l·∫°i tr·∫°ng th√°i sau khi ch·∫•m
  saveCurrentState();

  setTimeout(() => nextQuestion(), 700);
}

// ==================== NEXT QUESTION / L∆Ø·ª¢T M·ªöI ====================
function nextQuestion() {
  if (finished) return;

  if (current < roundList.length - 1) {
    current++;
    renderQuestion();
  } else {
    const statusEl = document.getElementById("status");
    if (wrongList.length > 0) {
      round++;

      let nextRound = [...wrongList];
      wrongList = [];
      if (shuffleEnabled) {
        nextRound = shuffleArray(nextRound);
      }
      roundList = nextRound;
      current = 0;

      statusEl.innerText =
        `B·∫°n v·∫´n c√≤n c√¢u sai. Chuy·ªÉn sang l∆∞·ª£t ${round} ch·ªâ g·ªìm c√°c c√¢u sai.`;
      statusEl.className = "err";
      renderQuestion();
    } else {
      finished = true;
      statusEl.innerText = "üéâ Ho√†n th√†nh! T·∫•t c·∫£ c√¢u h·ªèi ƒë·ªÅu ƒë√∫ng.";
      statusEl.className = "ok";
      saveCurrentState();
    }
  }
}

// ==================== L√ÄM L·∫†I T·ª™ ƒê·∫¶U ====================
function restartQuiz() {
  if (questions.length === 0) return;

  let indices = questions.map((_, i) => i);
  if (shuffleEnabled) {
    indices = shuffleArray(indices);
  }
  roundList = indices;
  wrongList = [];
  round = 1;
  current = 0;
  finished = false;
  renderQuestion();
}

// ====== INIT ======
function init() {
  attachChoiceEvents();
  refreshSavedSetsUI();
  quizHistory = loadHistoryFromLS();
  tryRestoreQuizState(); // th·ª≠ kh√¥i ph·ª•c b√†i ƒëang l√†m d·ªü
}

document.addEventListener("DOMContentLoaded", init);
</script>

</body>
</html>
